The rule said "create objects sparingly and discard them as quickly as possible"  
But, frequently re-creating some kinds of objects can lead to worse overall performance (even if GC performance improves).

## Heap analysis

Our tools operate only on live objects in the heap.  
Objects that will be reclaimed during the next full GC cycle are not included in the tools output.  
In some cases there are performance impact because teh tool perform full GC.

### Heap Histograms

Histogram output contain the number of objects within an application without doing a full heap dump (since heap dumps can take a while to analyze, and they consume a large amount of disk space).

Heap histograms can be obtained by using jcmd
```text
jcmd <process_id> GC.class_histogram
```

The output from GC.class_histogram includes only live objects, as the command normally forces a full GC. Use `-all` flag in the command to skip the full GC, though then the histogram contains unreferenced (garbage) objects.

We can use jmap to get same output  
```text
jmap -histo <process_id>
```  
The output from jmap includes objects that are eligible to be collected (dead objects).

To force full GC  
```text
jmap -histo:live <process_id>
```

### Heap Dumps

Used for deeper analysis.

Using jcmd  
```text
jcmd <process_id> GC.heap_dump heap_dump.hprof
```  
By default jcmp force a full GC. If for some reason we want other (dead) objects included, use -all at the end of the jcmd command line.

Using jmap  
```text
jmap -dump:live,file=heap_dump.hprof <process_id>
```  
Including the live option in jmap will force a full GC to occur before the heap is dumped.

Using full GC will obviously introduce a long pause into the application, but even if we don’t force a full GC, the application will be paused for the time it takes to write the heap dump.

From documentation _it is recommended to use the latest utility, `jcmd` instead of `jmap` utility for enhanced diagnostics and reduced performance overhead_

Other tools  
1. jvisualvm  
2. mat

#### Analysis process

The first-pass analysis of a heap is recognized retained memory.  
The retained memory of an object is the amount of memory that would be freed if the object itself were eligible to be collected.

Two other useful terms for memory analysis are shallow and deep.  
- The shallow size of an object is the size of the object itself.  
- The deep size of an object includes the size of the object it references.

Objects that retain a large amount of heap space are often called the _dominators_ of the heap. 
What we need to do if we found dominators in our dump file?  
- Try to reduce the number of them.  
- Retain them for a shorter period of time.  
- Simplify their object graph.  
- Make them smaller.

Looking at the objects that directly retain the largest amount of memory isn’t going to solve the memory issues. This is because of shared object.

The next step is use histogram, the histogram aggregates objects of the same type.

Heap analysis tools provide a way to find the GC roots of a particular object (or set of objects in this case). The GC roots are the system objects that hold a static, global reference that (through a long chain of other objects) refers to the object in question.  
The references here are a tree structure in reverse.  
Find the lowest point in the object graph where the target object is shared. This is done by examining the objects and their incoming references and tracing those incoming references until the duplicate path is identified.

### Out-of-Memory Errors

- Out-of-memory errors are thrown for a variety of reasons; do not assume that the heap space is the problem.  
- For both the metaspace and the regular heap, out-of-memory errors most frequently occur because of memory leaks; heap analysis tools can help to find the root cause of the leak.

#### Out of native (off-heap) memory

Besides the heap, the JVM allocates a fairly large chunk from the native memory to maintain its class metadata, application code, the code generated by JIT, internal data structures, etc.  
This memory allocated by the OS on behalf of the Java process through C code. This C code is called by `native` methods in certain Java classes.

Look into whatever native memory issue is mentioned in the error.  
However, be aware that the JVM will sometimes issue this error for things that have nothing to do with memory.  
```text
Exception in thread "main" java.lang.OutOfMemoryError:
unable to create new native thread
```
Users usually have constraints on the number of threads they can run; this constraint can be imposed by the OS or by a container.  
For example, in Linux, users are often allowed to create only 1,024 processes (a value you can check by running ulimit -u).  
The attempt to create a 1,025th thread will throw that same OutOfMemoryError, claiming insufficient memory to create the native thread, when in reality, the OS limit on the number of processes caused the error.

#### Out of metaspace memory

It occurs because the metaspace native memory is full.  
Because metaspace has no maximum size by default, this error typically occurs because we've chosen to set the maximum size.

This error can have two root causes:  
1. The first is simply that the application uses more classes than can fit in the metaspace we've assigned.  
2. The second case is trickier: it involves a classloader memory leak. This occurs most frequently in a server that loads classes dynamically.

If the old classloader does not go out of scope, the class metadata cannot be freed, and eventually the metaspace will fill up and throw an out-of-memory error.  
The key to recognizing this situation is again the full-text output of the out-of-memory error.  
```text
Exception in thread "main" java.lang.OutOfMemoryError: Metaspace
```  
Classloader leaks, by the way, are the reason you should consider setting the maximum size of the metaspace. Left unbounded, a system with a classloader leak will consume all the memory on your machine.

#### Out of heap memory

```text
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```  
The application may simply need more heap space:  
1. The number of live objects that it is holding onto cannot fit in the heap space configured for it. Increasing the heap size will solve the issue.  
2. The application may have a memory leak: it continues to allocate additional objects without allowing other objects to go out of scope. Increasing the heap size will merely postpone the error. Take successive heap dumps a few minutes apart and compare them.

The error only effect in single thread in the JVM, so the JVM does not exit. The surviving thread will try claimed the memory (after the error thread terminated) on a future GC cycle.

##### JVM flags to take automatically heap dump

1. `-XX:+HeapDumpOnOutOfMemoryError`  
2. `-XX:HeapDumpPath=<path>`  
3. `-XX:+HeapDumpAfterFullGC`  
4. `-XX:+HeapDumpBeforeFullGC`

Taking the heap dump(s) will extend the duration of the pause, because data representing the heap will be written to disk.

If we want the JVM to exit whenever the heap runs out of memory, we can set the `-XX:+ExitOnOutOfMemoryError` flag, which by default is false.

#### GC overhead limit reached

Normally when a thread gets the out-of-memory error, memory associated with whatever that thread is working on will become eligible for collection, and the JVM can recover.  
This error is thrown when _**all**_ of the following conditions are met:  
1. The amount of time spent in full GCs exceeds the value specified by the `-XX:GCTimeLimit=N` flag.  
2. The amount of memory reclaimed by a full GC is less than the value specified by the `-XX:GCHeapFreeLimit=N` flag.  
3. The preceding two conditions have held true for five consecutive full GC cycles (that value is not tunable).  
4. The value of the `-XX:+UseGCOverheadLimit` flag is true (which it is by default).

### Reference

[understanding java native memory](http://www.trevorsimonton.com/blog/2020/09/09/java-native-memory.html)  
[Native Memory — The Silent JVM Killer](https://medium.com/swlh/native-memory-the-silent-jvm-killer-595913cba8e7)  
[Native Memory Tracking in JVM](https://www.baeldung.com/native-memory-tracking-in-jvm)  
[Metaspace](https://wiki.openjdk.java.net/display/HotSpot/Metaspace)  
[What is Metaspace?](https://stuefe.de/posts/metaspace/what-is-metaspace/)  
[MetaSpace in Java 8 with Examples](https://www.geeksforgeeks.org/metaspace-in-java-8-with-examples/)